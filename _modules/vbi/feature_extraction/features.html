<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vbi.feature_extraction.features &#8212; vbi 0.1.dev1+g9cc934d documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=82a976d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/nature.css?v=8fc2db88" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=eafc0fe6" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=3fa40876"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">vbi 0.1.dev1+g9cc934d documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">vbi.feature_extraction.features</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for vbi.feature_extraction.features</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">vbi</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">moment</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurtosis</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">from</span> <span class="nn">vbi.feature_extraction.utility</span> <span class="kn">import</span> <span class="n">prepare_input_ts</span>
<span class="kn">from</span> <span class="nn">vbi.feature_extraction.features_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">km_order</span><span class="p">,</span>
    <span class="n">get_fc</span><span class="p">,</span>
    <span class="n">get_fcd</span><span class="p">,</span>
    <span class="n">matrix_stat</span><span class="p">,</span>
    <span class="n">compute_time</span><span class="p">,</span>
    <span class="n">init_jvm</span><span class="p">,</span>
    <span class="n">nat2bit</span><span class="p">,</span>
    <span class="n">kde</span><span class="p">,</span>
    <span class="n">gaussian</span><span class="p">,</span>
    <span class="n">calc_fft</span><span class="p">,</span>
    <span class="n">wavelet</span><span class="p">,</span>
    <span class="n">state_duration</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">jpype</span> <span class="k">as</span> <span class="nn">jp</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="abs_energy"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.abs_energy">[docs]</a><span class="k">def</span> <span class="nf">abs_energy</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the absolute energy of the time serie.</span>

<span class="sd">    &gt;&gt;&gt; abs_energy([1, 2, 3, 4, 5])</span>
<span class="sd">    (array([55]), [&#39;abs_energy_0&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-arrays [n_regions x n_samples]</span>
<span class="sd">        Input from which the area under the curve is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: list of float</span>
<span class="sd">        Absolute energy</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        Labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in abs_energy&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;abs_energy_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;abs_energy_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="average_power"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.average_power">[docs]</a><span class="k">def</span> <span class="nf">average_power</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the average power of the time serie.</span>

<span class="sd">    &gt;&gt;&gt; average_power([1, 2, 3, 4, 5], 1)</span>
<span class="sd">    (array([13.75]), [&#39;average_power_0&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-arrays [n_regions x n_samples]</span>
<span class="sd">        Input from which the area under the curve is computed</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: list of float</span>
<span class="sd">        Average power</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        Labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in average_power&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;average_power_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">compute_time</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ts</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;average_power_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="auc"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.auc">[docs]</a><span class="k">def</span> <span class="nf">auc</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the area under the curve of the signal computed with trapezoid rule.</span>

<span class="sd">    &gt;&gt;&gt; auc(np.array([[1, 2, 3], [4, 5, 6]]), None, np.array([0, 1, 2]))</span>
<span class="sd">    (array([ 4., 10.]), [&#39;auc_0&#39;, &#39;auc_1&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-arrays [n_regions x n_samples]</span>
<span class="sd">        Input from which the area under the curve is computed</span>
<span class="sd">    dx: float</span>
<span class="sd">        Spacing between values</span>
<span class="sd">    x: array_like, optional</span>
<span class="sd">        x values of the time series</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of float</span>
<span class="sd">        The area under the curve value</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        Labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in auc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;auc_0&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;auc_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="auc_lim"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.auc_lim">[docs]</a><span class="k">def</span> <span class="nf">auc_lim</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the area under the curve for a given time series within a given limit</span>

<span class="sd">    &gt;&gt;&gt; auc_lim(np.array([[1, 2, 3], [4, 5, 6]]), None, None, [(0, 1), (1, 2)])</span>
<span class="sd">    ([1.5, 4.5, 2.5, 5.5], [&#39;auc_lim_0&#39;, &#39;auc_lim_1&#39;, &#39;auc_lim_2&#39;, &#39;auc_lim_3&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-arrays [n_regions x n_samples]</span>
<span class="sd">        Input from which the area under the curve is computed</span>
<span class="sd">    dx: float</span>
<span class="sd">        Spacing between values</span>
<span class="sd">    x: array_like</span>
<span class="sd">        x values of the time series</span>
<span class="sd">    xlim: list of tuples</span>
<span class="sd">        The limits of the time series</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of float</span>
<span class="sd">        The area under the curve value</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        Labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in auc_lim&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;auc_lim_0&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;x and ts must have the same length&quot;</span>

    <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">xlim</span><span class="p">]</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xlim</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ts</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;auc_lim_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_var"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_var">[docs]</a><span class="k">def</span> <span class="nf">calc_var</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes variance of the time series.</span>

<span class="sd">    &gt;&gt;&gt; calc_var(np.array([[1, 2, 3], [4, 5, 6]]))</span>
<span class="sd">    (array([0.66666667, 0.66666667]), [&#39;var_0&#39;, &#39;var_1&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which var is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        variance of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_var&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;var_0&quot;</span><span class="p">]</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;var_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_std"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_std">[docs]</a><span class="k">def</span> <span class="nf">calc_std</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes standard deviation of the time serie.</span>

<span class="sd">    &gt;&gt;&gt; calc_std(np.array([[1, 2, 3], [4, 5, 6]]))</span>
<span class="sd">    (array([0.81649658, 0.81649658]), [&#39;std_0&#39;, &#39;std_1&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which std is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        std of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_std&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;std_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;std_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_mean"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_mean">[docs]</a><span class="k">def</span> <span class="nf">calc_mean</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes median of the time serie.</span>

<span class="sd">    &gt;&gt;&gt; calc_mean(np.array([[1, 2, 3], [4, 5, 6]]))</span>
<span class="sd">    (array([2., 5.]), [&#39;mean_0&#39;, &#39;mean_1&#39;])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which median is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        mean of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_mean&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mean_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mean_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_centroid"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_centroid">[docs]</a><span class="k">def</span> <span class="nf">calc_centroid</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the centroid along the time axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : nd-array</span>
<span class="sd">        Input from which centroid is computed</span>
<span class="sd">    fs: int</span>
<span class="sd">        Signal sampling frequency</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Temporal centroid</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_centroid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;centroid_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">compute_time</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">ts</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">energy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">energy_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ind_nonzero</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energy_sum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t_energy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">centroid</span><span class="p">[</span><span class="n">ind_nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_energy</span><span class="p">[</span><span class="n">ind_nonzero</span><span class="p">]</span> <span class="o">/</span> <span class="n">energy_sum</span><span class="p">[</span><span class="n">ind_nonzero</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;centroid_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroid</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_kurtosis"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_kurtosis">[docs]</a><span class="k">def</span> <span class="nf">calc_kurtosis</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the kurtosis of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which kurtosis is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        kurtosis of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_kurtosis&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;kurtosis_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">kurtosis</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;kurtosis_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_skewness"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_skewness">[docs]</a><span class="k">def</span> <span class="nf">calc_skewness</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the skewness of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which skewness is computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        skewness of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_skewness&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;skewness_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;skewness_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_max"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_max">[docs]</a><span class="k">def</span> <span class="nf">calc_max</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the maximum of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which maximum is computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        maximum of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_max&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;max_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;max_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_min"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_min">[docs]</a><span class="k">def</span> <span class="nf">calc_min</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the minimum of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which minimum is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        minimum of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_min&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;min_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;min_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_median"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_median">[docs]</a><span class="k">def</span> <span class="nf">calc_median</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the median of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which median is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        median of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_median&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;median_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;median_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="mean_abs_dev"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.mean_abs_dev">[docs]</a><span class="k">def</span> <span class="nf">mean_abs_dev</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the mean absolute deviation of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which mean absolute deviation is computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        mean absolute deviation of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in mean_abs_dev&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mean_abs_dev_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mean_abs_dev_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="median_abs_dev"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.median_abs_dev">[docs]</a><span class="k">def</span> <span class="nf">median_abs_dev</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the median absolute deviation of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which median absolute deviation is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        median absolute deviation of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in median_abs_dev&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;median_abs_dev_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;median_abs_dev_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the root mean square of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which root mean square is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        root mean square of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in rms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;rms_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;rms_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="interq_range"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.interq_range">[docs]</a><span class="k">def</span> <span class="nf">interq_range</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the interquartile range of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which interquartile range is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        interquartile range of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in interq_range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;interq_range_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;interq_range_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="zero_crossing"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.zero_crossing">[docs]</a><span class="k">def</span> <span class="nf">zero_crossing</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the number of zero crossings of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which number of zero crossings is computed</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        number of zero crossings of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in zero_crossing&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;zero_crossing_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y_i</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;zero_crossing_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<span class="c1"># def calc_ress(</span>
<span class="c1">#     ts: np.ndarray, percentile: Union[int, float] = 95, indices: List[int] = None</span>
<span class="c1"># ):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculates Residual Sum of Squares (RSS) with given percentile</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     ts : nd-array [n_regions x n_samples]</span>
<span class="c1">#          Input time seris</span>
<span class="c1">#     percentile : float</span>
<span class="c1">#             Percentile of RSS</span>
<span class="c1">#     indices: list of int</span>
<span class="c1">#         Indices of the time series to compute the feature</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     values: array-like</span>
<span class="c1">#         RSS of the time series</span>
<span class="c1">#     labels: array-like</span>
<span class="c1">#         labels of the features</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     info, ts = prepare_input_ts(ts, indices)</span>
<span class="c1">#     if not info:</span>
<span class="c1">#         return [np.nan], [f&quot;ress_{0}&quot;]</span>
<span class="c1">#     else:</span>
<span class="c1">#         nn, nt = ts.shape</span>
<span class="c1">#         rss = np.zeros(nt)</span>
<span class="c1">#         for t in range(nt):</span>
<span class="c1">#             z = np.power(np.outer(ts[:, t], ts[:, t]), 2)</span>
<span class="c1">#             rss[t] = np.sqrt(np.einsum(&quot;ij-&gt;&quot;, z))</span>
<span class="c1">#         return np.percentile(rss, percentile), [&quot;ress&quot;]</span>


<div class="viewcode-block" id="kop"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.kop">[docs]</a><span class="k">def</span> <span class="nf">kop</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Kuramoto order parameter (KOP)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in kop&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;kop&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">km_order</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;kop&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="calc_moments"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_moments">[docs]</a><span class="k">def</span> <span class="nf">calc_moments</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">orders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the moments of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which moments are computed</span>
<span class="sd">    orders: list</span>
<span class="sd">        List of orders of the moments</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        moments of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_moments&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;moments&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">moment</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">moment</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;moments_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))])</span>

        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_envelope"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_envelope">[docs]</a><span class="k">def</span> <span class="nf">calc_envelope</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">],</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate some statistics on envelope of the time series using hilbert transform</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in calc_envelope&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;envelope&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">analytic_signal</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">amplitude_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">)</span>
        <span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">))</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">(amplitude_envelope, axis=1)&quot;</span><span class="p">))</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;env_amp_</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">(instantaneous_phase, axis=1)&quot;</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;env_ph_</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="fc_sum"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.fc_sum">[docs]</a><span class="k">def</span> <span class="nf">fc_sum</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">masks</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sum of functional connectivity (FC)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which var is computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result: float</span>
<span class="sd">        sum of functional connectivity</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;fc_sum&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in fc_sum&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">masks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">nn</span><span class="p">))}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">masks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nn</span>
        <span class="p">),</span> <span class="s2">&quot;mask size must be equal to the number of regions&quot;</span>

    <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">positive</span><span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fc</span> <span class="o">*</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">masks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fc</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">masks</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="fc_stat"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.fc_stat">[docs]</a><span class="k">def</span> <span class="nf">fc_stat</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">positive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">eigenvalues</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pca_num_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">fc_function</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;corrcoef&quot;</span><span class="p">,</span>
    <span class="n">masks</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">quantiles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">],</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;skew&quot;</span><span class="p">,</span> <span class="s2">&quot;kurtosis&quot;</span><span class="p">],</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extract features from functional connectivity (FC)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>
<span class="sd">    k: int</span>
<span class="sd">        to remove up to kth diagonal of FC matrix</span>
<span class="sd">    pca_num_components: int</span>
<span class="sd">        number of components for PCA</span>
<span class="sd">    positive: bool</span>
<span class="sd">        if True, ignore negative values of fc elements</span>
<span class="sd">    masks: dict</span>
<span class="sd">        dictionary of masks</span>
<span class="sd">    features: list of str</span>
<span class="sd">        list of features to be extracted</span>
<span class="sd">    quantiles: list of float</span>
<span class="sd">        list of quantiles, set 0 to ignore</span>
<span class="sd">    eigenvalues: bool</span>
<span class="sd">        if True, extract features from eigenvalues</span>
<span class="sd">    fc_function: str</span>
<span class="sd">        functional connectivity function: &#39;corrcoef&#39; or &#39;cov&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stats: np.ndarray (1d)</span>
<span class="sd">        feature values</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        feature labels</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in fc_stat&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;fc_stat_0&quot;</span><span class="p">]</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;fc_stat_0&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">masks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">nn</span><span class="p">))}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">masks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nn</span>
        <span class="p">),</span> <span class="s2">&quot;mask size must be equal to the number of regions&quot;</span>

    <span class="n">Values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">fc</span> <span class="o">=</span> <span class="n">get_fc</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">fc_fucntion</span><span class="o">=</span><span class="n">fc_function</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="n">positive</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">matrix_stat</span><span class="p">(</span>
            <span class="n">fc</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">,</span>
            <span class="n">eigenvalues</span><span class="o">=</span><span class="n">eigenvalues</span><span class="p">,</span>
            <span class="n">pca_num_components</span><span class="o">=</span><span class="n">pca_num_components</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;fc_stat_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
        <span class="n">Values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">Labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Values</span><span class="p">,</span> <span class="n">Labels</span></div>


<div class="viewcode-block" id="fc_homotopic"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.fc_homotopic">[docs]</a><span class="k">def</span> <span class="nf">fc_homotopic</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">positive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">fc_function</span><span class="o">=</span><span class="s2">&quot;corrcoef&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the homotopic connectivity vector of a given brain activity</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bold: array_like [nn, nt]</span>
<span class="sd">        The brain activity to be analyzed.</span>
<span class="sd">    averag: bool</span>
<span class="sd">        If True, the average homotopic connectivity is returned.</span>
<span class="sd">        Otherwise, the homotopic connectivity vector is returned.</span>
<span class="sd">    positive: bool</span>
<span class="sd">        If True, only positive correlations are considered.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values : array_like [n_nodes]</span>
<span class="sd">        The homotopic correlation vector.</span>
<span class="sd">    labels : list of str</span>
<span class="sd">        The labels of the homotopic correlation vector.</span>

<span class="sd">    Negative correlations may be artificially induced when using global signal regression</span>
<span class="sd">    in functional imaging pre-processing (Fox et al., 2009; Murphy et al., 2009; Murphy and Fox, 2017).</span>
<span class="sd">    Therefore, results on negative weights should be interpreted with caution and should be understood</span>
<span class="sd">    as complementary information underpinning the findings based on positive connections</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">corrcoef</span><span class="p">,</span> <span class="n">cov</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in fc_homotopic&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;fc_homotopic&quot;</span><span class="p">]</span>

    <span class="n">nn</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;fc_homotopic&quot;</span><span class="p">]</span>

    <span class="n">NHALF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nn</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">fc_function</span><span class="p">)(</span><span class="n">ts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">positive</span><span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fc</span> <span class="o">*</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">fc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span>  <span class="c1"># not necessary for hfc</span>
    <span class="n">hfc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">NHALF</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hfc</span><span class="p">)],</span> <span class="p">[</span><span class="s2">&quot;fc_homotopic_avg&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">hfc</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;fc_homotopic_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="coactivation_degree"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.coactivation_degree">[docs]</a><span class="k">def</span> <span class="nf">coactivation_degree</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s2">&quot;noncor&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate coactivation degree (CAD) #!TODO not tested</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>
<span class="sd">    modality: str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        coactivation degree</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nn</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s2">&quot;cor&quot;</span><span class="p">:</span>
        <span class="n">global_signal</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nn</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">modality</span> <span class="o">!=</span> <span class="s2">&quot;cor&quot;</span><span class="p">:</span>
            <span class="n">global_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">global_signal</span>
    <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="coactivation_phase"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.coactivation_phase">[docs]</a><span class="k">def</span> <span class="nf">coactivation_phase</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate the coactivation phase (CAP) #!TODO not tested</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CAP: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># phase global</span>
    <span class="n">GS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">GS</span><span class="p">)))</span>
    <span class="n">Phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">Phase</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># phase regional</span>
    <span class="n">phase_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">phase_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase_i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">MSphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Phase</span> <span class="o">-</span> <span class="n">phase_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MSphase</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="burstiness"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.burstiness">[docs]</a><span class="k">def</span> <span class="nf">burstiness</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate the burstiness statistic</span>
<span class="sd">    - Goh and Barabasi, &#39;Burstiness and memory in complex systems&#39; Europhys. Lett.</span>
<span class="sd">    81, 48002 (2008).</span>
<span class="sd">    [from hctsa-py]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        Indices of the time series to compute the feature</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B: list of floats</span>
<span class="sd">        burstiness statistic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in burstiness&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;burstiness&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;burstiness&quot;</span><span class="p">]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;burstiness_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="fcd_stat"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.fcd_stat">[docs]</a><span class="k">def</span> <span class="nf">fcd_stat</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">TR</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">win_len</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">positive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">eigenvalues</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pca_num_components</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">quantiles</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">],</span>
    <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;skew&quot;</span><span class="p">,</span> <span class="s2">&quot;kurtosis&quot;</span><span class="p">],</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurtosis</span>
    
    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in fcd_stat&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;fcd_stat_0&quot;</span><span class="p">]</span>

    <span class="n">Values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_len</span> <span class="o">/</span> <span class="n">TR</span><span class="p">)</span>
    <span class="n">fcd</span> <span class="o">=</span> <span class="n">get_fcd</span><span class="p">(</span><span class="n">ts</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">TR</span><span class="o">=</span><span class="n">TR</span><span class="p">,</span> <span class="n">win_len</span><span class="o">=</span><span class="n">win_len</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="n">positive</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fcd</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">matrix_stat</span><span class="p">(</span>
            <span class="n">fcd</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">,</span>
            <span class="n">eigenvalues</span><span class="o">=</span><span class="n">eigenvalues</span><span class="p">,</span>
            <span class="n">pca_num_components</span><span class="o">=</span><span class="n">pca_num_components</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;fcd_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
        <span class="n">Values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">Labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Values</span><span class="p">,</span> <span class="n">Labels</span></div>


<div class="viewcode-block" id="calc_mi"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_mi">[docs]</a><span class="k">def</span> <span class="nf">calc_mi</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">time_diff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">source_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pairwise&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate the mutual information between time series</span>
<span class="sd">    based on the Kraskov method #!TODO bug in multiprocessing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>
<span class="sd">    k: int</span>
<span class="sd">        kth nearest neighbor</span>
<span class="sd">    time_diff: int</span>
<span class="sd">        time difference between time series</span>
<span class="sd">    num_threads: int</span>
<span class="sd">        number of threads</span>
<span class="sd">    source_indices: list or np.ndarray</span>
<span class="sd">        indices of source time series, if None, all time series are used</span>
<span class="sd">    target_indices: list or np.ndarray</span>
<span class="sd">        indices of target time series, if None, all time series are used</span>
<span class="sd">    mode: str</span>
<span class="sd">        &quot;pairwise&quot; or &quot;all&quot;, if &quot;pairwise&quot;, source_indices and target_indices must have the same length</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MI: list of floats</span>
<span class="sd">        mutual information</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_surrogates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_surrogates&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;ts must be a 2d array&quot;</span>

    <span class="n">init_jvm</span><span class="p">()</span>
    <span class="n">calcClass</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span>
        <span class="s2">&quot;infodynamics.measures.continuous.kraskov&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">MutualInfoCalculatorMultiVariateKraskov2</span>
    <span class="n">calc</span> <span class="o">=</span> <span class="n">calcClass</span><span class="p">()</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;NUM_THREADS&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;TIME_DIFF&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time_diff</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">startAddObservations</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">source_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">target_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">source_indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">target_indices</span><span class="p">:</span>
                <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pairwise&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_indices</span><span class="p">,</span> <span class="n">target_indices</span><span class="p">):</span>
            <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">finaliseAddObservations</span><span class="p">()</span>
    <span class="n">MI</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">num_surrogates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">NullDist</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">(</span><span class="n">num_surrogates</span><span class="p">)</span>
        <span class="n">NullMean</span> <span class="o">=</span> <span class="n">NullDist</span><span class="o">.</span><span class="n">getMeanOfDistribution</span><span class="p">()</span>
        <span class="n">MI</span> <span class="o">=</span> <span class="n">MI</span> <span class="o">-</span> <span class="n">NullMean</span> <span class="k">if</span> <span class="p">(</span><span class="n">MI</span> <span class="o">&gt;=</span> <span class="n">NullMean</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="n">MI</span> <span class="o">=</span> <span class="n">nat2bit</span><span class="p">(</span><span class="n">MI</span><span class="p">)</span>
    <span class="n">MI</span> <span class="o">=</span> <span class="n">MI</span> <span class="k">if</span> <span class="n">MI</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;mi&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">MI</span><span class="p">],</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span></div>


<div class="viewcode-block" id="calc_te"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_te">[docs]</a><span class="k">def</span> <span class="nf">calc_te</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">source_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pairwise&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate the transfer entropy between time series based on the Kraskov method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts: np.ndarray [n_regions, n_samples]</span>
<span class="sd">        input array</span>
<span class="sd">    num_threads: int</span>
<span class="sd">        number of threads</span>
<span class="sd">    source_indices: list or np.ndarray</span>
<span class="sd">        indices of source time series, if None, all time series are used</span>
<span class="sd">    target_indices: list or np.ndarray</span>
<span class="sd">        indices of target time series, if None, all time series are used</span>
<span class="sd">    mode: str</span>
<span class="sd">        &quot;pairwise&quot; or &quot;all&quot;, if &quot;pairwise&quot;, source_indices and target_indices must have the same length</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    TE: list of floats</span>
<span class="sd">        transfer entropy</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_surrogates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_surrogates&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;ts must have more than one time series&quot;</span>

    <span class="n">init_jvm</span><span class="p">()</span>
    <span class="n">calcClass</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span>
        <span class="s2">&quot;infodynamics.measures.continuous.kraskov&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">TransferEntropyCalculatorKraskov</span>
    <span class="n">calc</span> <span class="o">=</span> <span class="n">calcClass</span><span class="p">()</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;NUM_THREADS&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;DELAY&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">delay</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;AUTO_EMBED_RAGWITZ_NUM_NNS&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">)</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">startAddObservations</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">source_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">target_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">source_indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">target_indices</span><span class="p">:</span>
                <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pairwise&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_indices</span><span class="p">,</span> <span class="n">target_indices</span><span class="p">):</span>
            <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">calc</span><span class="o">.</span><span class="n">finaliseAddObservations</span><span class="p">()</span>
    <span class="n">te</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">num_surrogates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">NullDist</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">(</span><span class="n">num_surrogates</span><span class="p">)</span>
        <span class="n">NullMean</span> <span class="o">=</span> <span class="n">NullDist</span><span class="o">.</span><span class="n">getMeanOfDistribution</span><span class="p">()</span>
        <span class="c1"># NullStd = NullDist.getStdOfDistribution()</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">te</span> <span class="o">-</span> <span class="n">NullMean</span> <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">&gt;=</span> <span class="n">NullMean</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="n">te</span> <span class="o">=</span> <span class="n">te</span> <span class="k">if</span> <span class="n">te</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;te&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">te</span><span class="p">],</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span></div>


<div class="viewcode-block" id="calc_entropy"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_entropy">[docs]</a><span class="k">def</span> <span class="nf">calc_entropy</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate entropy of time series</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;entropy_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">labels</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">labels</span>

    <span class="n">init_jvm</span><span class="p">()</span>

    <span class="n">calcClass</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span>
        <span class="s2">&quot;infodynamics.measures.continuous.kozachenko&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">EntropyCalculatorMultiVariateKozachenko</span>
    <span class="n">calc</span> <span class="o">=</span> <span class="n">calcClass</span><span class="p">()</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">average</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
            <span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">nat2bit</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">())</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">nat2bit</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">())</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;entropy&quot;</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="calc_entropy_bin"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.calc_entropy_bin">[docs]</a><span class="k">def</span> <span class="nf">calc_entropy_bin</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;standard&quot;</span><span class="p">,</span> <span class="n">average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the entropy of the signal using the Shannon Entropy.</span>

<span class="sd">    Description in Article:</span>
<span class="sd">    Regularities Unseen, Randomness Observed: Levels of Entropy Convergence</span>
<span class="sd">    Authors: Crutchfield J. Feldman David</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : nd-array</span>
<span class="sd">        Input from which entropy is computed</span>
<span class="sd">    prob : string</span>
<span class="sd">        Probability function (kde or gaussian functions are available)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: float or array-like</span>
<span class="sd">        The normalized entropy value</span>
<span class="sd">    labels: string or array-like</span>
<span class="sd">        The label of the feature</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">one_dim</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prob</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">prob</span> <span class="o">==</span> <span class="s2">&quot;kde&quot;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">kde</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">prob</span> <span class="o">==</span> <span class="s2">&quot;gauss&quot;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># Handling zero probability values</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># If probability all in one value, there is no entropy</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;entropy_bin_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">one_dim</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;entropy_bin&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;entropy_bin_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="spectrum_stats"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.spectrum_stats">[docs]</a><span class="k">def</span> <span class="nf">spectrum_stats</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;fft&quot;</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;spectral_distance&quot;</span><span class="p">,</span>
        <span class="s2">&quot;fundamental_frequency&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_frequency&quot;</span><span class="p">,</span>
        <span class="s2">&quot;median_frequency&quot;</span><span class="p">,</span>
        <span class="s2">&quot;spectral_centroid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;spectral_kurtosis&quot;</span><span class="p">,</span>
        <span class="s2">&quot;spectral_variation&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute some statistics of the power spectrum of the time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which power spectrum statistics are computed</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to compute the power spectrum. Can be &#39;welch&#39; or &#39;fft&#39;</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        indices of the regions to be used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        power spectrum statistics of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_stats_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nperseg</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fft&quot;</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">calc_fft</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be one of &#39;welch&#39;, &#39;fft&#39;&quot;</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">freq</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">+</span> <span class="n">l</span>

    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="spectrum_auc"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.spectrum_auc">[docs]</a><span class="k">def</span> <span class="nf">spectrum_auc</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fft&quot;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate the area under the curve of the power spectrum of the time series over given frequency bands.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input time series</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to compute the power spectrum. Can be &#39;welch&#39; or &#39;fft&#39;</span>
<span class="sd">    bands : list of tuples</span>
<span class="sd">        Frequency bands</span>
<span class="sd">    nperseg: int</span>
<span class="sd">        Length of each segment. default is half of the time series</span>
<span class="sd">    avg: bool</span>
<span class="sd">        averaging psd over all regions</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        indices of the regions to be used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        area under the curve of the power spectrum of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_auc_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># r, c = ts.shape</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nperseg</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fft&quot;</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">calc_fft</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be one of &#39;welch&#39;, &#39;fft&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">70</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">band</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">band</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">band</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">psd_band</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">psd_band</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_auc_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spectrum_auc&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="spectrum_moments"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.spectrum_moments">[docs]</a><span class="k">def</span> <span class="nf">spectrum_moments</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fft&quot;</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">avg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">moments</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the moments of power spectrum</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">       Input from which power spectrum statistics are computed</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to compute the power spectrum. Can be &#39;welch&#39; or &#39;fft&#39;</span>
<span class="sd">    nperseg: int</span>
<span class="sd">        ...</span>
<span class="sd">    avg: bool</span>
<span class="sd">        averaging over all regions</span>
<span class="sd">    nm: list of int</span>
<span class="sd">        moments orders</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        power spectrum statistics of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_moment_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># r, c = ts.shape</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nperseg</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fft&quot;</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">calc_fft</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be one of &#39;welch&#39;, &#39;fft&#39;&quot;</span><span class="p">)</span>

        <span class="n">Values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">Labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">avg</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
            <span class="n">_m</span> <span class="o">=</span> <span class="n">moment</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Values</span><span class="p">,</span> <span class="n">_m</span><span class="p">)</span>
            <span class="n">Labels</span> <span class="o">=</span> <span class="n">Labels</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_moment_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_m</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">Values</span><span class="p">,</span> <span class="n">Labels</span></div>


<div class="viewcode-block" id="psd_raw"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.psd_raw">[docs]</a><span class="k">def</span> <span class="nf">psd_raw</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">,</span>
    <span class="n">bands</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">70</span><span class="p">)],</span>
    <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fft&quot;</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize_to</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># normalize to given value in Hz</span>
    <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate frequency spectrum and return with specified frequency resolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input time series</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency</span>
<span class="sd">    bands : list of tuples</span>
<span class="sd">        Frequency bands</span>
<span class="sd">    df : float</span>
<span class="sd">        Frequency resolution, default is fs / n_samples</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to compute the power spectrum. Can be &#39;welch&#39; or &#39;fft&#39;</span>
<span class="sd">    nperseg: int</span>
<span class="sd">        Length of each segment. default is half of the time series</span>
<span class="sd">    avg: bool</span>
<span class="sd">        averaging psd over all regions</span>
<span class="sd">    normalize: bool</span>
<span class="sd">        normalize the psd by the maximum value</span>
<span class="sd">    normalize_to: float</span>
<span class="sd">        normalize the psd to the given frequency value</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        indices of the regions to be used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    psd: array-like</span>
<span class="sd">        power spectrum density</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spectrum_moment_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># r, c = ts.shape</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nperseg</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fft&quot;</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">calc_fft</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be one of &#39;welch&#39;, &#39;fft&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalize_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;normalize and normalize_to cannot be used together&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the value is in the frequency range</span>
            <span class="k">if</span> <span class="n">normalize_to</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">normalize_to</span> <span class="o">&gt;</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;normalize_to must be in the range of 0 to fs/2&quot;</span><span class="p">)</span>

            <span class="c1"># find index of the frequency closest to the given value</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">normalize_to</span><span class="p">))</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span> <span class="o">/</span> <span class="n">psd</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fr_intp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">psd_intp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">fr_intp</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">psd</span>
        <span class="p">)</span>

        <span class="n">psd_bands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">fr_intp</span> <span class="o">&gt;=</span> <span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fr_intp</span> <span class="o">&lt;</span> <span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">psd_bands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psd_bands</span><span class="p">,</span> <span class="n">psd_intp</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="n">psd_bands</span> <span class="o">=</span> <span class="n">psd_bands</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;psd_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psd_bands</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">psd_bands</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="wavelet_abs_mean_1d"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.wavelet_abs_mean_1d">[docs]</a><span class="k">def</span> <span class="nf">wavelet_abs_mean_1d</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes CWT absolute mean value of each wavelet scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array</span>
<span class="sd">        Input from which CWT is computed</span>
<span class="sd">    function :  wavelet function</span>
<span class="sd">        Default: scipy.signal.ricker</span>
<span class="sd">    widths :  nd-array</span>
<span class="sd">        Widths to use for transformation</span>
<span class="sd">        Default: np.arange(1,10)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        CWT absolute mean value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wavelet</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">widths</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span></div>


<div class="viewcode-block" id="wavelet_abs_mean"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.wavelet_abs_mean">[docs]</a><span class="k">def</span> <span class="nf">wavelet_abs_mean</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &quot;&quot;&quot;Computes CWT absolute mean value of each wavelet scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input from which CWT is computed</span>
<span class="sd">    function :  wavelet function</span>
<span class="sd">        Default: scipy.signal.ricker</span>
<span class="sd">    widths :  nd-array</span>
<span class="sd">        Widths to use for transformation</span>
<span class="sd">        Default: np.arange(1,10)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        CWT absolute mean value of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;wavelet_abs_mean_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wavelet_abs_mean_1d</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">function</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;wavelet_abs_mean_n</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_w</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="wavelet_std"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.wavelet_std">[docs]</a><span class="k">def</span> <span class="nf">wavelet_std</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes CWT std value of each wavelet scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input from which CWT is computed</span>
<span class="sd">    function :  wavelet function</span>
<span class="sd">        Default: scipy.signal.ricker</span>
<span class="sd">    widths :  nd-array</span>
<span class="sd">        Widths to use for transformation</span>
<span class="sd">        Default: np.arange(1,10)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        CWT std value of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;wavelet_std_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">wavelet</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">function</span><span class="p">,</span> <span class="n">widths</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;wavelet_std_n</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_w</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="wavelet_energy_1d"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.wavelet_energy_1d">[docs]</a><span class="k">def</span> <span class="nf">wavelet_energy_1d</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes CWT energy of each wavelet scale.</span>

<span class="sd">    Implementation details:</span>
<span class="sd">    https://stackoverflow.com/questions/37659422/energy-for-1-d-wavelet-in-python</span>

<span class="sd">    Feature computational cost: 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : nd-array</span>
<span class="sd">        Input from which CWT is computed</span>
<span class="sd">    function :  wavelet function</span>
<span class="sd">        Default: scipy.signal.ricker</span>
<span class="sd">    widths :  nd-array</span>
<span class="sd">        Widths to use for transformation</span>
<span class="sd">        Default: np.arange(1,10)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        CWT energy</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cwt</span> <span class="o">=</span> <span class="n">wavelet</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cwt</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">cwt</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span></div>


<div class="viewcode-block" id="wavelet_energy"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.wavelet_energy">[docs]</a><span class="k">def</span> <span class="nf">wavelet_energy</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes CWT energy of each wavelet scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input from which CWT is computed</span>
<span class="sd">    function :  wavelet function</span>
<span class="sd">        Default: scipy.signal.ricker</span>
<span class="sd">    widths :  nd-array</span>
<span class="sd">        Widths to use for transformation</span>
<span class="sd">        Default: np.arange(1,10)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values: array-like</span>
<span class="sd">        CWT energy of the time series</span>
<span class="sd">    labels: array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;wavelet_energy_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wavelet_energy_1d</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">function</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;wavelet_energy_n</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_w</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>


<span class="c1"># -----------------------------------------------------------------------------</span>


<div class="viewcode-block" id="hmm_stat"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.hmm_stat">[docs]</a><span class="k">def</span> <span class="nf">hmm_stat</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">node_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_states</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">subname</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">observations</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;em&quot;</span><span class="p">,</span>
    <span class="n">tcut</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the state duration of the HMM.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input from which HMM is computed</span>
<span class="sd">    node_indices : list</span>
<span class="sd">        List of node indices to be used for HMM</span>
<span class="sd">    n_states : int</span>
<span class="sd">        Number of states</span>
<span class="sd">    subname : str</span>
<span class="sd">        subname for the labels</span>
<span class="sd">    n_iter : int</span>
<span class="sd">        Number of iterations</span>
<span class="sd">    seed : int</span>
<span class="sd">        Random seed</span>
<span class="sd">    observations : str</span>
<span class="sd">        Observation distribution</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to fit the HMM</span>
<span class="sd">    t_cut : int</span>
<span class="sd">        maximum duration of a state, default is 5</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stat_vec : array-like</span>
<span class="sd">        HMM features</span>
<span class="sd">    labels : array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;hmm_dur&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">obs</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">node_indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">nt</span><span class="p">,</span> <span class="n">obs_dim</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">ssm</span><span class="o">.</span><span class="n">HMM</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">obs_dim</span><span class="p">,</span> <span class="n">observations</span><span class="o">=</span><span class="n">observations</span><span class="p">)</span>
        <span class="n">model_lls</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hmm_z</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">most_likely_states</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        <span class="c1"># emmision_hmm_z, emmision_hmm_y = model.sample(nt) #!TODO: check if need to be used</span>
        <span class="c1"># hmm_x = model.smooth(obs)</span>
        <span class="c1"># upper = np.triu_indices(n_states, 0)</span>
        <span class="n">trans_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># [upper]</span>

        <span class="n">stat_duration</span> <span class="o">=</span> <span class="n">state_duration</span><span class="p">(</span><span class="n">hmm_z</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tcut</span><span class="o">=</span><span class="n">tcut</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;hmm</span><span class="si">{</span><span class="n">subname</span><span class="si">}</span><span class="s2">_dur_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stat_duration</span><span class="p">))]</span>
        <span class="n">labels</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;hmm</span><span class="si">{</span><span class="n">subname</span><span class="si">}</span><span class="s2">_trans_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">))]</span>
        <span class="n">stat_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">stat_duration</span><span class="p">,</span> <span class="n">trans_mat</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">stat_vec</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="catch22"><a class="viewcode-back" href="../../../feature_extraction.html#vbi.feature_extraction.features.catch22">[docs]</a><span class="k">def</span> <span class="nf">catch22</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">catch24</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">features</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;DN_HistogramMode_5&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DN_HistogramMode_10&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CO_f1ecac&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CO_FirstMin_ac&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CO_HistogramAMI_even_2_5&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CO_trev_1_num&quot;</span><span class="p">,</span>
        <span class="s2">&quot;MD_hrv_classic_pnn40&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SB_BinaryStats_mean_longstretch1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SB_TransitionMatrix_3ac_sumdiagcov&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PD_PeriodicityWang_th0_01&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CO_Embed2_Dist_tau_d_expfit_meandiff&quot;</span><span class="p">,</span>
        <span class="s2">&quot;IN_AutoMutualInfoStats_40_gaussian_fmmi&quot;</span><span class="p">,</span>
        <span class="s2">&quot;FC_LocalSimple_mean1_tauresrat&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DN_OutlierInclude_p_001_mdrmd&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DN_OutlierInclude_n_001_mdrmd&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SP_Summaries_welch_rect_area_5_1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SB_BinaryStats_diff_longstretch0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SB_MotifThree_quantile_hh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SC_FluctAnal_2_rsrangefit_50_1_logi_prop_r1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SC_FluctAnal_2_dfa_50_1_2_logi_prop_r1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SP_Summaries_welch_rect_centroid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;FC_LocalSimple_mean3_stderr&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Catch22 features.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : nd-array [n_regions x n_samples]</span>
<span class="sd">        Input from which Catch22 features are computed</span>
<span class="sd">    node_indices : list</span>
<span class="sd">        List of node indices to be used for Catch22</span>
<span class="sd">    catch24 : bool</span>
<span class="sd">        If True, calculate mean and std of the features</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values : array-like</span>
<span class="sd">        feature values</span>
<span class="sd">    labels : array-like</span>
<span class="sd">        labels of the features</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">catch22_C</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;pycatch22 is not installed. Please install it using `pip install pycatch22`&quot;</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">catch24</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;DN_Mean&#39;</span><span class="p">)</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;DN_Spread_Std&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">get_features</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">f_fun</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">catch22_C</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_fun</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">prepare_input_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
       <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;catch22&quot;</span><span class="p">]</span>
 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="mi">22</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">catch24</span> <span class="k">else</span> <span class="mi">24</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nn</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">get_features</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">features</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span>  <span class="n">features</span> <span class="o">*</span> <span class="n">nn</span>

        <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">labels</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">vbi 0.1.dev1+g9cc934d documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">vbi.feature_extraction.features</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, Abolfazl Ziaeemehr.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>